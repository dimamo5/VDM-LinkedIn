class Person
types
-- TODO Define types here
values
-- TODO Define values here
instance variables
-- TODO Define instance variables here
   public connects : set of Person := {};
   public name: Utils`String;
   private myCommendations : Commendations := new Commendations();
   private academics : set of AcademicEducation := {};
   private experiences : set of Experience := {};
   private other :Utils`String :="";
   
operations
	public Person: Utils`String ==> Person
         Person(n) == (name:=n; return self)
         post connects = {} and academics = {} and myCommendations.commList = {|->}; 
         
  public addConnect:Person ==> ()
  		addConnect(person)==(
  				addPerson(person);
  				person.addPerson(self);
  			)
  			pre person not in set connects and self not in set person.connects
  			post person in set connects and self in set person.connects;
  			
  public addPerson:Person ==> ()
  			addPerson(person) ==
  			connects:= connects union {person}
  			pre person not in set connects
  			post person in set connects;
	
	public addAcademicEducation: AcademicEducation`InstitutionName * AcademicEducation`AcademicDescription * AcademicEducation`Year ==> ()
					addAcademicEducation(inst,desc,year) ==
					academics:= academics union {new AcademicEducation(inst,desc,year)}; 
	
	public removeAcademicEducationObj: AcademicEducation ==> ()
		removeAcademicEducationObj(academicEducation) == 
			academics := academics \ {academicEducation}
			pre academicEducation in set academics
			post academics <> academics~ 
				and academicEducation not in set academics; 
	
	public addCommendation: Person * Commendations`Skill ==> ()
				addCommendation(person,skill) == 
					myCommendations.addRecomendation(person,skill)
				pre  person in set connects 											-- so as conexoes podem recomendar
					and myCommendations.canRecommend(person,skill) 
				post not myCommendations.canRecommend(person,skill);
				
	public removeCommendation: Person * Commendations`Skill ==> ()
		removeCommendation(person,skill) == 
			myCommendations.removeRecommendation(person,skill)
			pre person in set connects;
			
	public addExperience: Experience`String * Experience`String * Experience`String ==> () 
		addExperience(nm,title,description) ==
			experiences := experiences union {new Experience(nm,title,description)};
					
	public removeExperience : Experience ==> ()
		removeExperience(experience) == 
			experiences := experiences \ {experience}
			pre experience in set experiences
			post experience not in set experiences;
			
	public addOtherCV : Utils`String ==> ()
		addOtherCV(cv) ==
			other:= other ^ cv
			post len other > len other~;
			
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Person