class Person
types
-- TODO Define types here
values
-- TODO Define values here
instance variables
-- TODO Define instance variables here
   public connects : set of Person := {};
   public name: Utils`String;
   private myCommendations : Commendations := new Commendations();
   private academics : set of AcademicEducation := {};
   private experiences : set of Experience := {};
   --private address :set of char;
operations
-- TODO Define operations here
	public Person: Utils`String ==> Person
         Person(n) == (name:=n; return self)
         post connects = {} and academics = {} and myCommendations.commList = {|->}; 
	
	public addAcademicEducation: AcademicEducation`InstitutionName * AcademicEducation`AcademicDescription * AcademicEducation`Year ==> ()
					addAcademicEducation(inst,desc,year) ==
					academics:= academics union {new AcademicEducation(inst,desc,year)}; 
	
	public removeAcademicEducation: AcademicEducation ==> ()
		removeAcademicEducation(AcademicEducation) == 
			academics := academics \ {AcademicEducation}
			pre AcademicEducation in set academics
			post academics <> academics~ 
				and AcademicEducation not in set academics; 
	
	public addCommendation: Person * Commendations`Skill ==> ()
				addCommendation(person,skill) == 
					myCommendations.addRecomendation(person,skill)
				pre  person in set connects 											-- so as conexoes podem recomendar
					and myCommendations.canRecommend(person,skill) 
				post not myCommendations.canRecommend(person,skill);
				
	public removeCommendation: Person * Commendations`Skill ==> ()
		removeCommendation(person,skill) == 
			myCommendations.removeRecommendation(person,skill)
			pre person in set connects
					
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Person